{% extends "tabs.html" %}

{% block content %}
<h1>AI Trading Feedback Dashboard</h1>
<div style="background: #e3f2fd; padding: 10px; border-radius: 5px; margin-bottom: 20px; font-size: 14px;">
    <strong>üìä Configuration:</strong> <span id="currentConfigHash">Loading...</span>
</div>

<!-- Current Prompt Versions -->
<div class="portfolio-summary">
    <div class="metric-card" id="summarizerVersionCard">
        <h3>üìä Summarizer Prompt</h3>
        <p class="value" id="summarizerVersion">--</p>
    </div>
    <div class="metric-card" id="deciderVersionCard">
        <h3>üéØ Decider Prompt</h3>
        <p class="value" id="deciderVersion">--</p>
    </div>
</div>

<!-- Performance Metrics -->
<div class="portfolio-summary">
    <div class="metric-card">
        <h3>Success Rate (30d)</h3>
        <p class="value" id="successRate">--</p>
    </div>
    <div class="metric-card">
        <h3>Average Profit (30d)</h3>
        <p class="value" id="avgProfit">--</p>
    </div>
    <div class="metric-card">
        <h3>Total Trades (30d)</h3>
        <p class="value" id="tradeCount">--</p>
    </div>
    <div class="metric-card">
        <h3>Feedback Count</h3>
        <p class="value" id="feedbackCount">--</p>
    </div>
</div>

<style>
.portfolio-summary {
    display: flex;
    gap: 20px;
    margin-bottom: 30px;
    flex-wrap: wrap;
}
.metric-card {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 20px;
    min-width: 180px;
    text-align: center;
}
.metric-card h3 {
    margin: 0 0 10px 0;
    color: #495057;
    font-size: 14px;
    font-weight: 600;
}
.metric-card .value {
    margin: 0;
    font-size: 24px;
    font-weight: bold;
    color: #212529;
}
.feedback-section {
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    margin-bottom: 20px;
}
.feedback-content {
    background: #f8f9fa;
    padding: 15px;
    border-left: 4px solid #007bff;
    margin: 10px 0;
    border-radius: 4px;
}
.feedback-history-item {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 15px;
    margin: 10px 0;
}
.feedback-history-item h4 {
    margin: 0 0 10px 0;
    color: #495057;
    font-size: 16px;
}
.feedback-history-item .timestamp {
    font-size: 12px;
    color: #666;
    margin-bottom: 10px;
}
.feedback-history-item .content {
    background: white;
    padding: 10px;
    border-radius: 4px;
    white-space: pre-wrap;
    font-size: 13px;
    max-height: 200px;
    overflow-y: auto;
}
.feedback-history-container {
    max-height: 600px;
    overflow-y: auto;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 15px;
    background: #f8f9fa;
}
.feedback-history-container::-webkit-scrollbar {
    width: 8px;
}
.feedback-history-container::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}
.feedback-history-container::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 4px;
}
.feedback-history-container::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}
.outcomes-table {
    width: 100%;
    border-collapse: collapse;
    background: white;
}
.outcomes-table th,
.outcomes-table td {
    padding: 12px;
    text-align: left;
    border-bottom: 1px solid #ddd;
}
.outcomes-table th {
    background-color: #f8f9fa;
    font-weight: bold;
}
.outcome-significant_profit { background-color: #d4edda; }
.outcome-moderate_profit { background-color: #d1ecf1; }
.outcome-break_even { background-color: #fff3cd; }
.outcome-moderate_loss { background-color: #f8d7da; }
.outcome-significant_loss { background-color: #f5c6cb; }
.refresh-btn {
    background: #007bff;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    margin-bottom: 20px;
}
.refresh-btn:hover {
    background: #0056b3;
}
.chart-container {
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    margin-bottom: 20px;
    height: 400px;
}
.text-success {
    color: #28a745 !important;
}
.text-danger {
    color: #dc3545 !important;
}
.outcomes-table th {
    cursor: pointer;
    user-select: none;
    position: relative;
    padding-right: 20px;
}
.outcomes-table th:hover {
    background-color: #e9ecef;
}
.outcomes-table th.sortable::after {
    content: " ‚ÜïÔ∏è";
    position: absolute;
    right: 8px;
    opacity: 0.5;
}
.outcomes-table th.sort-asc::after {
    content: " ‚Üë";
    opacity: 1;
    color: #007bff;
}
.outcomes-table th.sort-desc::after {
    content: " ‚Üì";
    opacity: 1;
    color: #007bff;
}
</style>

<!-- Latest Feedback Analysis -->
<div class="feedback-section">
    <h2>üß† Latest Feedback Analysis</h2>
    <div id="latestFeedback">
        <p>Loading latest feedback...</p>
    </div>
</div>

<!-- Feedback History -->
<div class="feedback-section">
    <h2>üìã Feedback History (Last 10)</h2>
    <div class="feedback-history-container">
        <div id="feedbackHistory">
            <p>Loading feedback history...</p>
        </div>
    </div>
</div>

<!-- Current vs Previous Prompts -->
<div class="feedback-section">
    <h2>üîÑ Current vs Previous Prompts</h2>
    <div id="promptComparison">
        <p>Loading prompt comparison...</p>
    </div>
</div>

<!-- Recent Trade Outcomes -->
<div class="feedback-section">
    <h2>üìä Recent Trade Outcomes</h2>
    <div style="overflow-x: auto;">
        <table class="outcomes-table" id="outcomesTable">
            <thead>
                <tr>
                    <th class="sortable" data-column="ticker">Ticker</th>
                    <th class="sortable" data-column="sell_date">Sell Date</th>
                    <th class="sortable" data-column="shares">Shares</th>
                    <th class="sortable" data-column="purchase_price">Purchase Price</th>
                    <th class="sortable" data-column="sell_price">Sell Price</th>
                    <th class="sortable" data-column="net_gain_dollars">Net Gain ($)</th>
                    <th class="sortable" data-column="gain_loss_pct">Gain/Loss %</th>
                    <th class="sortable" data-column="category">Category</th>
                    <th class="sortable" data-column="hold_days">Hold Days</th>
                </tr>
            </thead>
            <tbody id="outcomesBody">
                <tr><td colspan="9">Loading...</td></tr>
            </tbody>
        </table>
    </div>
</div>

<!-- Performance Chart -->
<div class="chart-container">
    <canvas id="performanceChart"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    let performanceChart = null;

    async function loadLatestFeedback() {
        const feedbackDiv = document.getElementById('latestFeedback');
        
        try {
            const response = await fetch('/api/feedback');
            if (!response.ok) {
                throw new Error(`Failed to fetch feedback: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.status === 'success' && data.latest_feedback) {
                const feedback = data.latest_feedback;
                const timestamp = new Date().toLocaleString();
                
                let html = `
                    <div class="feedback-history-item">
                        <h4>üìä Analysis Summary (${feedback.total_trades_analyzed} trades)</h4>
                        <div class="timestamp">Generated: ${timestamp}</div>
                        <div style="margin-bottom: 15px;">
                            <strong>Success Rate:</strong> ${(feedback.success_rate * 100).toFixed(1)}%<br>
                            <strong>Average Profit:</strong> ${feedback.avg_profit_percentage.toFixed(2)}%
                        </div>
                        
                        <h4>üìù Summarizer Guidance:</h4>
                        <div class="content">${formatFeedback(feedback.summarizer_feedback)}</div>
                        
                        <h4>üéØ Decider Guidance:</h4>
                        <div class="content">${formatFeedback(feedback.decider_feedback)}</div>
                        
                        ${feedback.recommended_adjustments && feedback.recommended_adjustments.key_insights ? `
                            <h4>üí° Key Insights:</h4>
                            <ul style="margin-top: 10px;">
                                ${feedback.recommended_adjustments.key_insights.map(insight => `<li>${insight}</li>`).join('')}
                            </ul>
                        ` : ''}
                    </div>
                `;
                
                feedbackDiv.innerHTML = html;
                
                // Update metrics
                if (data.period_analysis && data.period_analysis['30d']) {
                    const period30d = data.period_analysis['30d'];
                    document.getElementById('successRate').textContent = `${(period30d.success_rate * 100).toFixed(1)}%`;
                    document.getElementById('avgProfit').textContent = `${(period30d.avg_profit * 100).toFixed(2)}%`;
                    document.getElementById('tradeCount').textContent = period30d.total_trades;
                }
                
                // Update performance chart
                if (data.period_analysis) {
                    updatePerformanceChart(data.period_analysis);
                }
            } else {
                feedbackDiv.innerHTML = '<p>No recent feedback analysis available</p>';
            }
        } catch (error) {
            console.error('Error loading latest feedback:', error);
            feedbackDiv.innerHTML = `<p style="color: red;">Error loading feedback: ${error.message}</p>`;
        }
    }

    async function loadFeedbackHistory() {
        const historyDiv = document.getElementById('feedbackHistory');
        
        try {
            const response = await fetch('/api/feedback_log');
            if (!response.ok) {
                throw new Error(`Failed to fetch feedback history: ${response.status}`);
            }
            
            const feedbackLog = await response.json();
            
            if (!Array.isArray(feedbackLog) || feedbackLog.length === 0) {
                historyDiv.innerHTML = '<p>No feedback history available</p>';
                document.getElementById('feedbackCount').textContent = '0';
                return;
            }
            
            document.getElementById('feedbackCount').textContent = feedbackLog.length;
            
            // Limit to last 10 entries
            const recentFeedback = feedbackLog.slice(0, 10);
            
            let html = '';
            recentFeedback.forEach((entry, index) => {
                const timestamp = new Date(entry.timestamp).toLocaleString();
                
                html += `
                    <div class="feedback-history-item">
                        <h4>üìä Feedback Analysis #${feedbackLog.length - index}</h4>
                        <div class="timestamp">${timestamp} (${entry.lookback_days} days lookback)</div>
                        <div style="margin-bottom: 15px;">
                            <strong>Trades Analyzed:</strong> ${entry.trades_analyzed}<br>
                            <strong>Success Rate:</strong> ${entry.success_rate.toFixed(1)}%<br>
                            <strong>Average Profit:</strong> ${entry.avg_profit.toFixed(2)}%
                        </div>
                        
                        <h4>üìù Summarizer Guidance:</h4>
                        <div class="content">${formatFeedback(entry.summarizer_feedback)}</div>
                        
                        <h4>üéØ Decider Guidance:</h4>
                        <div class="content">${formatFeedback(entry.decider_feedback)}</div>
                    </div>
                `;
            });
            
            historyDiv.innerHTML = html;
            
        } catch (error) {
            console.error('Error loading feedback history:', error);
            historyDiv.innerHTML = `<p style="color: red;">Error loading feedback history: ${error.message}</p>`;
        }
    }

    function formatFeedback(feedback) {
        if (!feedback || feedback === 'null') return 'No specific guidance available';
        
        // Remove quotes if they exist
        let cleaned = feedback;
        if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
            cleaned = cleaned.slice(1, -1);
        }
        
        return cleaned;
    }

    function updatePerformanceChart(periodData) {
        const ctx = document.getElementById('performanceChart').getContext('2d');
        
        if (performanceChart) {
            performanceChart.destroy();
        }
        
        const periods = ['7d', '14d', '30d'];
        const successRates = periods.map(p => (periodData[p]?.success_rate || 0) * 100);
        const avgProfits = periods.map(p => (periodData[p]?.avg_profit || 0) * 100);
        
        performanceChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: ['7 Days', '14 Days', '30 Days'],
                datasets: [
                    {
                        label: 'Success Rate (%)',
                        data: successRates,
                        borderColor: '#4CAF50',
                        backgroundColor: 'rgba(76, 175, 80, 0.1)',
                        yAxisID: 'y'
                    },
                    {
                        label: 'Average Profit (%)',
                        data: avgProfits,
                        borderColor: '#2196F3',
                        backgroundColor: 'rgba(33, 150, 243, 0.1)',
                        yAxisID: 'y1'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: { display: true, text: 'Success Rate (%)' }
                    },
                    y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        title: { display: true, text: 'Average Profit (%)' },
                        grid: { drawOnChartArea: false }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Performance Trends'
                    }
                }
            }
        });
    }

    let currentOutcomes = [];
    let currentSort = { column: 'sell_date', direction: 'desc' };

    async function loadTradeOutcomes() {
        try {
            const response = await fetch('/api/trade_outcomes');
            const outcomes = await response.json();
            
            if (Array.isArray(outcomes)) {
                currentOutcomes = outcomes;
                updateOutcomesTable(currentOutcomes);
                setupTableSorting();
            }
        } catch (error) {
            console.error('Error loading trade outcomes:', error);
        }
    }

    function updateOutcomesTable(outcomes) {
        const tbody = document.getElementById('outcomesBody');
        
        if (outcomes.length === 0) {
            tbody.innerHTML = '<tr><td colspan="9">No trade outcomes recorded yet</td></tr>';
            return;
        }
        
        tbody.innerHTML = outcomes.map(outcome => {
            const netGainClass = outcome.net_gain_dollars >= 0 ? 'text-success' : 'text-danger';
            const netGainValue = outcome.net_gain_dollars >= 0 ? 
                `$${outcome.net_gain_dollars.toFixed(2)}` : 
                `-$${Math.abs(outcome.net_gain_dollars).toFixed(2)}`;
            
            const percentageClass = outcome.gain_loss_pct >= 0 ? 'text-success' : 'text-danger';
            const percentageValue = outcome.gain_loss_pct >= 0 ? 
                `${outcome.gain_loss_pct.toFixed(2)}%` : 
                `-${Math.abs(outcome.gain_loss_pct).toFixed(2)}%`;
            
            return `
                <tr class="outcome-${outcome.category}">
                    <td><strong>${outcome.ticker}</strong></td>
                    <td>${new Date(outcome.sell_date).toLocaleDateString()}</td>
                    <td>${outcome.shares.toFixed(0)}</td>
                    <td>$${outcome.purchase_price.toFixed(2)}</td>
                    <td>$${outcome.sell_price.toFixed(2)}</td>
                    <td class="${netGainClass}"><strong>${netGainValue}</strong></td>
                    <td class="${percentageClass}"><strong>${percentageValue}</strong></td>
                    <td>${outcome.category.replace('_', ' ').toUpperCase()}</td>
                    <td>${outcome.hold_days || 'N/A'}</td>
                </tr>
            `;
        }).join('');
    }

    function setupTableSorting() {
        const headers = document.querySelectorAll('.outcomes-table th.sortable');
        
        headers.forEach(header => {
            header.addEventListener('click', () => {
                const column = header.dataset.column;
                
                // Toggle sort direction if same column, otherwise default to ascending
                if (currentSort.column === column) {
                    currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    currentSort = { column, direction: 'asc' };
                }
                
                // Update header styles
                headers.forEach(h => {
                    h.classList.remove('sort-asc', 'sort-desc');
                });
                header.classList.add(currentSort.direction === 'asc' ? 'sort-asc' : 'sort-desc');
                
                // Sort and update table
                sortOutcomes(column, currentSort.direction);
            });
        });
        
        // Set initial sort indicator
        const defaultHeader = document.querySelector(`[data-column="${currentSort.column}"]`);
        if (defaultHeader) {
            defaultHeader.classList.add(`sort-${currentSort.direction}`);
        }
    }

    function sortOutcomes(column, direction) {
        const sortedOutcomes = [...currentOutcomes].sort((a, b) => {
            let aVal = a[column];
            let bVal = b[column];
            
            // Handle different data types
            switch (column) {
                case 'sell_date':
                    aVal = new Date(aVal);
                    bVal = new Date(bVal);
                    break;
                case 'shares':
                case 'purchase_price':
                case 'sell_price':
                case 'net_gain_dollars':
                case 'gain_loss_pct':
                case 'hold_days':
                    aVal = parseFloat(aVal) || 0;
                    bVal = parseFloat(bVal) || 0;
                    break;
                case 'ticker':
                case 'category':
                    aVal = String(aVal).toLowerCase();
                    bVal = String(bVal).toLowerCase();
                    break;
            }
            
            if (aVal < bVal) return direction === 'asc' ? -1 : 1;
            if (aVal > bVal) return direction === 'asc' ? 1 : -1;
            return 0;
        });
        
        updateOutcomesTable(sortedOutcomes);
    }

    async function loadPromptComparison() {
        const comparisonDiv = document.getElementById('promptComparison');
        
        try {
            // Load prompts for both agents
            const [summarizerResponse, deciderResponse] = await Promise.all([
                fetch('/api/prompts/SummarizerAgent'),
                fetch('/api/prompts/DeciderAgent')
            ]);
            
            if (!summarizerResponse.ok || !deciderResponse.ok) {
                throw new Error('Failed to fetch prompt data');
            }
            
            const summarizerPrompts = await summarizerResponse.json();
            const deciderPrompts = await deciderResponse.json();
            
            let html = '';
            
            // Summarizer prompts comparison
            if (Array.isArray(summarizerPrompts) && summarizerPrompts.length > 0) {
                html += `
                    <div class="feedback-history-item">
                        <h4>üìä Summarizer Agent Prompts</h4>
                        ${generatePromptComparison(summarizerPrompts, 'summarizer')}
                    </div>
                `;
            }
            
            // Decider prompts comparison
            if (Array.isArray(deciderPrompts) && deciderPrompts.length > 0) {
                html += `
                    <div class="feedback-history-item">
                        <h4>üéØ Decider Agent Prompts</h4>
                        ${generatePromptComparison(deciderPrompts, 'decider')}
                    </div>
                `;
            }
            
            if (!html) {
                html = '<p>No prompt history available</p>';
            }
            
            comparisonDiv.innerHTML = html;
            
        } catch (error) {
            console.error('Error loading prompt comparison:', error);
            comparisonDiv.innerHTML = `<p style="color: red;">Error loading prompt comparison: ${error.message}</p>`;
        }
    }

    function generatePromptComparison(prompts, agentType) {
        if (prompts.length === 0) {
            return '<p>No prompts available</p>';
        }
        
        // Sort by version (newest first)
        const sortedPrompts = prompts.sort((a, b) => b.prompt_version - a.prompt_version);
        const currentPrompt = sortedPrompts[0];
        const previousPrompt = sortedPrompts[1];
        
        let html = '';
        
        // Current prompt
        html += `
            <div style="margin: 15px 0; padding: 15px; background: #d4edda; border-left: 4px solid #28a745; border-radius: 4px;">
                <h5>üÜï Current Prompt (v${currentPrompt.prompt_version})</h5>
                <div class="timestamp">${new Date(currentPrompt.timestamp).toLocaleString()}</div>
                <div style="margin-top: 10px;">
                    <strong>System Prompt:</strong>
                    <div class="content">${currentPrompt.system_prompt}</div>
                </div>
                <div style="margin-top: 10px;">
                    <strong>User Prompt Template:</strong>
                    <div class="content">${currentPrompt.user_prompt}</div>
                </div>
                ${currentPrompt.description ? `
                    <div style="margin-top: 10px;">
                        <strong>Description:</strong> ${currentPrompt.description}
                    </div>
                ` : ''}
            </div>
        `;
        
        // Previous prompt (if exists)
        if (previousPrompt) {
            html += `
                <div style="margin: 15px 0; padding: 15px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
                    <h5>üìù Previous Prompt (v${previousPrompt.prompt_version})</h5>
                    <div class="timestamp">${new Date(previousPrompt.timestamp).toLocaleString()}</div>
                    <div style="margin-top: 10px;">
                        <strong>System Prompt:</strong>
                        <div class="content">${previousPrompt.system_prompt}</div>
                    </div>
                    <div style="margin-top: 10px;">
                        <strong>User Prompt Template:</strong>
                        <div class="content">${previousPrompt.user_prompt}</div>
                    </div>
                    ${previousPrompt.description ? `
                        <div style="margin-top: 10px;">
                            <strong>Description:</strong> ${previousPrompt.description}
                        </div>
                    ` : ''}
                </div>
            `;
        } else {
            html += `
                <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-left: 4px solid #6c757d; border-radius: 4px;">
                    <p><em>No previous prompt version available</em></p>
                </div>
            `;
        }
        
        return html;
    }

    let lastKnownPromptVersions = {};

    function refreshData() {
        loadLatestFeedback();
        loadFeedbackHistory();
        loadPromptComparison();
        loadTradeOutcomes();
        checkForPromptReset();
    }

    async function checkForPromptReset() {
        try {
            // Check current active prompt versions
            const [summarizerResponse, deciderResponse] = await Promise.all([
                fetch('/api/prompts/SummarizerAgent/active'),
                fetch('/api/prompts/DeciderAgent/active')
            ]);
            
            if (summarizerResponse.ok && deciderResponse.ok) {
                const summarizerPrompt = await summarizerResponse.json();
                const deciderPrompt = await deciderResponse.json();
                
                const currentVersions = {
                    SummarizerAgent: summarizerPrompt.version || summarizerPrompt.prompt_version,
                    DeciderAgent: deciderPrompt.version || deciderPrompt.prompt_version
                };
                
                // Update the prompt version displays
                updatePromptVersionDisplays(currentVersions, summarizerPrompt, deciderPrompt);
                
                // Check if versions changed (indicating a reset or prompt update)
                if (Object.keys(lastKnownPromptVersions).length > 0) {
                    let versionChanged = false;
                    for (const agent in currentVersions) {
                        if (lastKnownPromptVersions[agent] !== currentVersions[agent]) {
                            console.log(`üìù Detected prompt version change for ${agent}: v${lastKnownPromptVersions[agent]} ‚Üí v${currentVersions[agent]}`);
                            versionChanged = true;
                            
                            // Highlight the changed version
                            highlightVersionChange(agent, currentVersions[agent]);
                        }
                    }
                    
                    if (versionChanged) {
                        // Show notification about reset
                        showResetNotification();
                        // Refresh prompt comparison immediately
                        loadPromptComparison();
                    }
                }
                
                lastKnownPromptVersions = currentVersions;
            }
        } catch (error) {
            console.error('Error checking for prompt reset:', error);
        }
    }

    function updatePromptVersionDisplays(versions, summarizerPrompt, deciderPrompt) {
        // Update summarizer version
        const summarizerEl = document.getElementById('summarizerVersion');
        const summarizerDesc = summarizerPrompt.description || 'Active prompt';
        summarizerEl.innerHTML = `v${versions.SummarizerAgent}<br><small style="font-size: 12px; opacity: 0.8;">${summarizerDesc}</small>`;
        
        // Update decider version
        const deciderEl = document.getElementById('deciderVersion');
        const deciderDesc = deciderPrompt.description || 'Active prompt';
        deciderEl.innerHTML = `v${versions.DeciderAgent}<br><small style="font-size: 12px; opacity: 0.8;">${deciderDesc}</small>`;
        
        // Color code based on version (v4 = green baseline, others = blue)
        const summarizerCard = document.getElementById('summarizerVersionCard');
        const deciderCard = document.getElementById('deciderVersionCard');
        
        summarizerCard.style.backgroundColor = versions.SummarizerAgent === 4 ? '#d4edda' : '#d1ecf1';
        summarizerCard.style.borderLeft = versions.SummarizerAgent === 4 ? '4px solid #28a745' : '4px solid #17a2b8';
        
        deciderCard.style.backgroundColor = versions.DeciderAgent === 4 ? '#d4edda' : '#d1ecf1';
        deciderCard.style.borderLeft = versions.DeciderAgent === 4 ? '4px solid #28a745' : '4px solid #17a2b8';
    }

    function highlightVersionChange(agent, newVersion) {
        const cardId = agent === 'SummarizerAgent' ? 'summarizerVersionCard' : 'deciderVersionCard';
        const card = document.getElementById(cardId);
        
        // Add a brief highlight animation
        card.style.transition = 'all 0.3s ease';
        card.style.boxShadow = '0 0 20px rgba(255, 193, 7, 0.8)';
        card.style.transform = 'scale(1.05)';
        
        // Remove highlight after 2 seconds
        setTimeout(() => {
            card.style.boxShadow = '';
            card.style.transform = '';
        }, 2000);
    }

    function showResetNotification() {
        // Create a temporary notification
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            font-weight: bold;
        `;
        notification.innerHTML = 'üîÑ Portfolio reset detected - Prompts updated to v4 baseline';
        
        document.body.appendChild(notification);
        
        // Remove notification after 5 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 5000);
    }

    // Load data on page load
    document.addEventListener('DOMContentLoaded', function() {
        refreshData();
        loadConfigInfo();
        
        // Auto-refresh every 10 seconds (more frequent to catch resets)
        setInterval(refreshData, 10000);
    });

    function loadConfigInfo() {
        // Display current configuration hash
        fetch('/api/configuration')
            .then(response => response.json())
            .then(data => {
                const configElement = document.getElementById('currentConfigHash');
                const configHash = data.config_hash || 'Unknown';
                const model = data.gpt_model || 'Unknown';  // Fixed: was data.model
                const promptMode = data.prompt_config?.mode || 'Unknown';  // Fixed: was data.prompt_mode
                
                // Format prompt display like trades.html
                let promptDisplay;
                if (promptMode === 'auto') {
                    const promptVersions = data.prompt_versions || {};
                    promptDisplay = `AUTO (v${promptVersions.summarizer_version || 0}/v${promptVersions.decider_version || 0})`;
                } else {
                    promptDisplay = `FIXED v${data.prompt_config?.forced_version || 0}`;
                }
                
                configElement.innerHTML = `${configHash} (${model}, ${promptDisplay})`;
            })
            .catch(error => {
                document.getElementById('currentConfigHash').textContent = 'Error loading config';
            });
    }
</script>
{% endblock %}